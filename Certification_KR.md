# Certification - Associated 시험 문제

## 빠른 정답 확인
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| ① | ④ | ① | ③ | ② | ③ | ① | ① | ① | ③ |

| 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| ③ | ③ | ③ | ③ | ③ | ④ | ③ | ① | ② | ③ |

| 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| ④ | ③ | ② | ③ | ① | ③ | ② | ① | ③ | ① |

| 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| ③ | ④ | ① | ② | ① | ② | ③ | ① | ② | ② |

| 41 | 42 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| ③ | ③ | ① | ① | ② | ① | ③ | ③ | ④ | ④ |

| 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| ① | ① | ② | ④ | ③ | ③ | ④ | ① | ③ | ④ |

| 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| ② | ② | ① | ② | ④ | ④ | ③ | ① | ④ | ② |

| 71 | 72 | 73 | 74 | 75 |
| --- | --- | --- | --- | --- |
| ③ | ① | ④ | ④ | ① |


---

## 문제 1

Is it possible to Expose a REST API in OutSystems? (OutSystems에서 REST API를 노출(Expose)하는 것이 가능합니까?)

- [x] **A. Yes (예)**
- [ ] B. No (아니요)

> **해설**
> **Answer:** A
> OutSystems 플랫폼에서는 REST API를 노출(Expose)할 수 있습니다. 이를 통해 외부 시스템이
> OutSystems 애플리케이션과 통신할 수 있도록 API를 제공할 수 있습니다. 따라서 정답은 **A.
> Yes**입니다.

---

## 문제 2

Select the correct option regarding the Input Widget. (Input 위젯에 대한 올바른 옵션을 선택하세요.)

- [ ] A. All input widgets must be inside a Form widget. (모든 input 위젯은 Form 위젯 안에 있어야 합니다.)
- [ ] B. You don't need to have a variable. The data typed by the user is saved in the Input widget itself. (변수가 필요하지 않습니다. 사용자가 입력한 데이터는 Input 위젯 자체에 저장됩니다.)
- [ ] C. It can only be associated to variables of Text data type. (Text 데이터 유형의 변수에만 연결할 수 있습니다.)
- [x] **D. You always need to have a variable to store the value typed by the user. (사용자가 입력한 값을 저장하려면 항상 변수가 필요합니다.)**

> **해설**
> **Answer:** D
> OutSystems에서 Input Widget은 사용자가 입력한 데이터를 저장하기 위해 반드시 변수(Variable)
> 와 연결되어야 합니다. 입력된 데이터는 Input Widget 자체에 저장되지 않고, 연결된 변수에 저장
> 됩니다. 따라서 정답은 **D. You always need to have a variable to store the value typed by the
> user**입니다.

---

## 문제 3

In Rich Widgets, the List_Navigation widget….. (Rich Widget에서 List_Navigation 위젯은...)

- [x] **A. Is a navigator for a Table Records with multiple pages, showing a defined number of elements per page. (페이지당 정의된 수의 요소를 표시하는 여러 페이지가 있는 Table Records의 네비게이터입니다.)**
- [ ] B. Is a navigator for a Form with multiple pages, showing a defined number of elements per page. (페이지당 정의된 수의 요소를 표시하는 여러 페이지가 있는 Form의 네비게이터입니다.)

> **해설**
> **Answer:** A
> List_Navigation 위젯은 OutSystems의 Rich Widgets에 포함된 것으로, Table Records를 페이지 단
> 위로 나누어 표시하고 페이지 간 탐색을 지원하는 위젯입니다. Form과는 관련이 없으므로 정답은
> **A. Is a navigator for a Table Records with multiple pages, showing a defined number of elements
> per page**입니다.

---

## 문제 4

Regarding Expression on the screen, which of the following options is true? (화면의 Expression에 대해 다음 중 옳은 것은 무엇입니까?)

- [ ] A. Expression can call server action and use the server action output to calculate (Expression은 서버 액션을 호출하고 서버 액션 출력을 사용하여 계산할 수 있습니다.)
- [ ] B. If the expression is empty, the value shown in the Example property will be displayed (Expression이 비어 있으면 Example 속성에 표시된 값이 표시됩니다.)
- [x] **C. The value of Expression will be calculated during the build screen and displayed on the screen (Expression 값은 화면 빌드 중에 계산되어 화면에 표시됩니다.)**
- [ ] D. Expression cannot call server action and uses server action output to calculate (Expression은 서버 액션을 호출할 수 없으며 서버 액션 출력을 사용하여 계산합니다.)

> **해설**
> **Answer:** C
> OutSystems에서 Expression은 화면이 빌드될 때 계산되어 화면에 표시됩니다. Expression은 주로
> 클라이언트 측에서 계산되며, 서버 액션을 직접 호출하지는 않습니다. 따라서 정답은 **C. The
> value of Expression will be calculated during the build screen and displayed on the screen**입니다.

---

## 문제 5

Style classes can be overriden, so if you have the same style class defined in a Web Block, a Screen, and the Theme, which definition is applied? (스타일 클래스는 재정의될 수 있습니다. Web Block, Screen, Theme에 동일한 스타일 클래스가 정의된 경우 어떤 정의가 효율적입니까?)

- [ ] A. The one in the Web Block. (Web Block에 있는 것.)
- [x] **B. The one in the Screen. (Screen에 있는 것.)**
- [ ] C. The one in the Theme. (Theme에 있는 것.)
- [ ] D. The one in the UI Flow. (UI Flow에 있는 것.)

> **해설**
> **Answer:** B
> OutSystems에서 스타일 클래스는 계층 구조에 따라 우선순위가 결정됩니다. 동일한 스타일 클래
> 스가 Web Block, Screen, Theme에 정의된 경우, 가장 구체적인 수준인 **Screen**에 정의된 스타
> 일이 우선적으로 적용됩니다. 따라서 정답은 **B. The one in the Screen**입니다.

---

## 문제 6

When doing a "With or Without" join between tow entities, it returns.. (두 엔티티 간에 "With or Without" 조인을 수행하면 무엇을 반환합니까?)

- [ ] A. All records from both entities(FULL OUTER JOIN) (두 엔티티의 모든 레코드(FULL OUTER JOIN))
- [ ] B. Only records where there is match between the tow entities(INNER JOIN) (두 엔티티 간에 일치하는 레코드만(INNER JOIN))
- [x] **C. All records from the left entity even if there is no match in the right entity(LEFT JOIN) (오른쪽 엔티티에 일치하는 것이 없더라도 왼쪽 엔티티의 모든 레코드(LEFT JOIN))**
- [ ] D. All records from the right entity even if there is no match in the left entity(RIGHT JOIN) (왼쪽 엔티티에 일치하는 것이 없더라도 오른쪽 엔티티의 모든 레코드(RIGHT JOIN))

> **해설**
> **Answer:** C
> OutSystems에서 "With or Without" 조인은 SQL의 LEFT JOIN에 해당합니다. 이는 왼쪽 엔티티의
> 모든 레코드를 반환하며, 오른쪽 엔티티에 매칭되는 레코드가 없더라도 왼쪽 엔티티의 레코드는
> 포함됩니다. 따라서 정답은 **C. All records from the left entity even if there is no match in the right
> entity(LEFT JOIN)**입니다.

---

## 문제 7

Regarding List_SortColumn, which of the following options is true? (List_SortColumn에 대해 다음 중 옳은 것은 무엇입니까?)

- [x] **A. Set the Column to '{EntityName}.[AttributeName]' & define a dynamic sort (Column을 '{EntityName}.[AttributeName]'으로 설정하고 동적 정렬을 정의합니다.)**
- [ ] B. Set the Column to '{EntityName}.[AttributeName]' & Automatic add a dynamic sort (Column을 '{EntityName}.[AttributeName]'으로 설정하고 동적 정렬을 자동으로 추가합니다.)
- [ ] C. Set the Column to '{EntityName}.{AttributeName}' & define a dynamic sort (Column을 '{EntityName}.{AttributeName}'으로 설정하고 동적 정렬을 정의합니다.)
- [ ] D. Set the Column to '{EntityName}.{AttributeName}' & Automatic add a dynamic sort (Column을 '{EntityName}.{AttributeName}'으로 설정하고 동적 정렬을 자동으로 추가합니다.)

> **해설**
> **Answer:** A
> List_SortColumn 위젯은 동적 정렬을 정의하기 위해 사용됩니다. 이때 Column 속성은
> `{EntityName}.[AttributeName]` 형식으로 설정해야 하며, 개발자가 동적 정렬을 명시적으로 정의해
> 야 합니다. 자동으로 동적 정렬이 추가되지는 않습니다. 따라서 정답은 **A. Set the Column to
> '{EntityName}.[AttributeName]' & define a dynamic sort**입니다.

---

## 문제 8

Entities and Attributes are created in the database as... (엔티티와 속성은 데이터베이스에서 무엇으로 생성됩니까?)

- [x] **A. Tables and Columns (테이블 및 컬럼)**
- [ ] B. Tables and Indexes (테이블 및 인덱스)
- [ ] C. Indexes and Columns (인덱스 및 컬럼)
- [ ] D. Tables and Constraints (테이블 및 제약 조건)

> **해설**
> **Answer:** A
> OutSystems에서 엔티티(Entity)는 데이터베이스에서 테이블(Table)로 생성되며, 엔티티의 속성
> (Attribute)은 해당 테이블의 컬럼(Column)으로 생성됩니다. 따라서 정답은 **A. Tables and
> Columns**입니다.

---

## 문제 9

To speed up application development, OutSystems has pre-built screens with logic and data for typical scenarios (애플리케이션 개발 속도를 높이기 위해 OutSystems는 일반적인 시나리오를 위한 로직과 데이터가 포함된 사전 제작된 화면을 제공합니다.)

- [x] **A. TRUE (참)**
- [ ] B. FALSE (거짓)

> **해설**
> **Answer:** A
> OutSystems는 애플리케이션 개발 속도를 높이기 위해 일반적인 시나리오에 맞는 사전 제작된 화
> 면(Pre-built Screens)과 로직, 데이터를 제공합니다. 예를 들어, 목록 화면이나 상세 화면 등을 쉽
> 게 생성할 수 있습니다. 따라서 정답은 **A. TRUE**입니다.

---

## 문제 10

The Check Box widget is bound to a Variable of type. (Check Box 위젯은 어떤 유형의 변수에 바인딩됩니까?)

- [ ] A. Text (텍스트)
- [ ] B. Integer (정수)
- [x] **C. Boolean (불리언)**
- [ ] D. Date (날짜)

> **해설**
> **Answer:** C
> Check Box 위젯은 사용자가 선택하거나 선택 해제할 수 있는 이진 상태를 나타내며, 이는
> Boolean 타입(참/거짓) 변수와 연결됩니다. 따라서 정답은 **C. Boolean**입니다.

---

## 문제 11

Consider a Web Screen with a Button that is associated to a Screen Action. An Ajax Refresh statement in that Screen Action allows to refresh part of that Web Screen, ... (Screen Action과 연결된 버튼이 있는 웹 화면을 고려하세요. 해당 Screen Action의 Ajax Refresh 구문은 웹 화면의 일부를 새로 고칠 수 있도록 허용합니다...)

- [ ] A. if the button has Method Navigate. (버튼의 Method가 Navigate인 경우.)
- [ ] B. regardless of the Button's Method. (버튼의 Method에 관계없이.)
- [x] **C. if the Button has Method Ajax Submit. (버튼의 Method가 Ajax Submit인 경우.)**
- [ ] D. if the Button has Method Submit. (버튼의 Method가 Submit인 경우.)

> **해설**
> **Answer:** C
> Ajax Refresh는 화면의 특정 부분만 새로고침하는 데 사용됩니다. 이는 버튼의 Method가 **Ajax
> Submit**으로 설정된 경우에 가능합니다. Navigate는 화면 전환, Submit은 전체 페이지 새로고침
> 을 유발하므로 Ajax Refresh와 관련이 없습니다. 따라서 정답은 **C. if the Button has Method Ajax
> Submit**입니다.

---

## 문제 12

When you want to display a widget in a certain role, what is the best way? (특정 역할(Role)에서 위젯을 표시하고 싶을 때 가장 좋은 방법은 무엇입니까?)

- [ ] A. The widget's Visible property setting is Check < RoleName> Role (UserId) = True (위젯의 Visible 속성 설정이 Check < RoleName> Role (UserId) = True인 경우)
- [ ] B. Use Container to display control with Display property as Check < RoleName> Role (UserId) = True (Display 속성이 Check < RoleName> Role (UserId) = True인 컨테이너를 사용하여 컨트롤을 표시합니다.)
- [x] **C. Use the If condition to display control provided that Check < RoleName> Role (UserId) = True (Check < RoleName> Role (UserId) = True인 경우 컨트롤을 표시하기 위해 If 조건을 사용합니다.)**
- [ ] D. Cannot perform the display in units of each widget, so it cannot be done (각 위젯 단위로 표시를 수행할 수 없으므로 불가능합니다.)

> **해설**
> **Answer:** C
> 특정 역할(Role)에 따라 위젯을 표시하려면 **If 조건**을 사용하여 해당 역할이 참인지 확인하는
> 것이 가장 적합합니다. If 위젯을 사용하면 조건에 따라 위젯을 동적으로 표시하거나 숨길 수 있습
> 니다. Visible 속성이나 Container의 Display 속성은 직접적으로 역할 체크를 지원하지 않습니다.
> 따라서 정답은 **C. Use the If condition to display control provided that Check < RoleName> Role
> (UserId) = True**입니다.

---

## 문제 13

Output parameters are available ... (출력 매개변수(Output parameters)를 사용할 수 있는 범위는...)

- [ ] A. Only inside their implementation scope. (해당 구현 범위 내에서만.)
- [ ] B. Only outside their implementation scope. (해당 구현 범위 밖에서만.)
- [x] **C. Both inside and outside their implementation scope. (구현 범위 안팎 모두.)**

> **해설**
> **Answer:** C
> OutSystems에서 출력 매개변수(Output Parameters)는 액션의 구현 범위 내에서도 사용 가능하며,
> 해당 액션을 호출한 외부 범위에서도 사용할 수 있습니다. 따라서 정답은 **C. Both inside and
> outside their implementation scope**입니다.

---

## 문제 14

Regarding Web Blocks in Outsystems, select to statement that is true. (OutSystems의 Web Block에 대해 다음 중 옳은 문장을 선택하세요.)

- [ ] A. Web Block can only have 1 output (Web Block은 하나의 출력만 가질 수 있습니다.)
- [ ] B. Web Block cannot have preparation action (Web Block은 Preparation 액션을 가질 수 없습니다.)
- [x] **C. Web Block can Preparation action (Web Block은 Preparation 액션을 가질 수 있습니다.)**
- [ ] D. Web Block can have multiple outputs (Web Block은 여러 출력을 가질 수 있습니다.)

> **해설**
> **Answer:** C
> Web Block은 OutSystems에서 재사용 가능한 UI 구성 요소로, Preparation 액션을 가질 수 있습니
> 다. Preparation 액션은 Web Block이 렌더링되기 전에 데이터를 준비하는 데 사용됩니다. Web
> Block은 여러 출력 매개변수를 가질 수 없으며, Preparation 액션은 필수가 아닙니다. 따라서 정답
> 은 **C. Web Block can Preparation action**입니다.

---

## 문제 15

Consider a Web Screen with a Button that is associated to a Screen Action. An Ajax Refresh statement in that Screen Action allows to refresh part of that Web Screen, ... (Screen Action과 연결된 버튼이 있는 웹 화면을 고려하세요. 해당 Screen Action의 Ajax Refresh 구문은 웹 화면의 일부를 새로 고칠 수 있도록 허용합니다...)

- [ ] A. if the button has Method Navigate. (버튼의 Method가 Navigate인 경우.)
- [ ] B. regardless of the Button's Method. (버튼의 Method에 관계없이.)
- [x] **C. if the Button has Method Ajax Submit. (버튼의 Method가 Ajax Submit인 경우.)**
- [ ] D. if the Button has Method Submit. (버튼의 Method가 Submit인 경우.)

> **해설**
> **Answer:** C
> Ajax Refresh는 화면의 특정 부분만 새로고침하는 데 사용됩니다. 이는 버튼의 Method가 **Ajax
> Submit**으로 설정된 경우에 가능합니다. Navigate는 화면 전환, Submit은 전체 페이지 새로고침
> 을 유발하므로 Ajax Refresh와 관련이 없습니다. 따라서 정답은 **C. if the Button has Method Ajax
> Submit**입니다.

---

## 문제 16

When the desired data type is Currency, the following data type transmission does not occur(error) (원하는 데이터 유형이 Currency인 경우, 다음 중 발생하지 않는 데이터 유형 전송(오류)은 무엇입니까?)

- [ ] A. Decimal, Integer, Long Integer (Decimal, 정수, Long Integer)
- [ ] B. Long Integer, Integer, Boolean, Entity Identifier(Integer) (Long Integer, 정수, 불리언, 엔티티 식별자(정수))
- [ ] C. Decimal, Long Integer, Boolean, Entity Identifier(Integer) (Decimal, Long Integer, 불리언, 엔티티 식별자(정수))
- [x] **D. Decimal, Integer, Boolean, Entity Identifier(Integer) (Decimal, 정수, 불리언, 엔티티 식별자(정수))**

> **해설**
> **Answer:** D
> Currency 데이터 타입은 주로 Decimal로 처리되며, Integer, Boolean, Entity Identifier(Integer)로의
> 변환은 오류 없이 가능합니다. 그러나 Long Integer는 Currency로 변환 시 정밀도 문제로 오류가
> 발생할 수 있습니다. 따라서 오류가 발생하지 않는 조합은 **D. Decimal, Integer, Boolean, Entity
> Identifier(Integer)**입니다.

---

## 문제 17

What is the correct syntax for writing names of Entities and Entity Attributes in SQL Query (SQL 쿼리에서 엔티티 및 엔티티 속성 이름을 작성하는 올바른 구문은 무엇입니까?)

- [ ] A. <Entity> and <Entity>.[Attribute] (<Entity> 및 <Entity>.[Attribute])
- [ ] B. {Entity} and {Entity}.{Attribute} ({Entity} 및 {Entity}.{Attribute})
- [x] **C. {Entity} and {Entity}.[Attribute] ({Entity} 및 {Entity}.[Attribute])**
- [ ] D. <Entity> and <Entity>.<Attribute> (<Entity> 및 <Entity>.<Attribute>)

> **해설**
> **Answer:** C
> OutSystems에서 SQL 쿼리 작성 시 엔티티와 속성 이름은 `{Entity}.[Attribute]` 형식으로 작성해야
> 합니다. 이는 OutSystems의 표준 구문입니다. 따라서 정답은 **C. {Entity} and {Entity}.[Attribute]**
> 입니다.
> ---

---

## 문제 18

What types of applications can be created in OutSystems? (OutSystems에서 어떤 유형의 애플리케이션을 생성할 수 있습니까?)

- [x] **A. Web, Mobile and Service (웹, 모바일 및 서비스)**
- [ ] B. Web, Mobile, Service and Extension (웹, 모바일, 서비스 및 익스텐션)
- [ ] C. Module and Extension (모듈 및 익스텐션)
- [ ] D. Only Web (웹 전용)

> **해설**
> **Answer:** A
> OutSystems에서는 Web, Mobile, Service 애플리케이션을 생성할 수 있습니다. Extension은 별도의
> 모듈 타입으로 간주되지 않으며, Module은 애플리케이션의 구성 요소일 뿐입니다. 따라서 정답은
> **A. Web, Mobile and Service**입니다.

---

## 문제 19

What is the output of an aggregate when no records meet the criteria? (기준을 충족하는 레코드가 없을 때 Aggregate의 출력은 무엇입니까?)

- [ ] A. Null List (Null 리스트)
- [x] **B. Empty list (빈 리스트)**
- [ ] C. List has an empty record (리스트에 빈 레코드가 있음)
- [ ] D. List has a record with default data (리스트에 기본 데이터가 포함된 레코드가 있음)

> **해설**
> **Answer:** B
> OutSystems에서 Aggregate가 기준을 충족하는 레코드를 찾지 못하면 빈 리스트(Empty List)를 반
> 환합니다. Null이나 기본 데이터가 포함된 레코드는 반환되지 않습니다. 따라서 정답은 **B. Empty
> list**입니다.

---

## 문제 20

The Check Box widget is bound to a Variable of type... (Check Box 위젯은 다음 유형의 변수에 바인딩됩니다...)

- [ ] A. Text (텍스트)
- [ ] B. Integer (정수)
- [x] **C. Boolean (불리언)**
- [ ] D. Date (날짜)

> **해설**
> **Answer:** C
> Check Box 위젯은 사용자가 선택하거나 선택 해제할 수 있는 이진 상태를 나타내며, 이는
> Boolean 타입(참/거짓) 변수와 연결됩니다. 따라서 정답은 **C. Boolean**입니다.

---

## 문제 21

Create unique customer index with 2 fields Name and Email. When performing any insert data below, an error will occur (Name과 Email 두 필드로 고유한 고객 인덱스를 생성합니다. 아래 데이터를 삽입할 때 오류가 발생하는 경우는 언제입니까?)

- [ ] A. (Jonh,jonh@gmail.com,1122),(Jonh_Hand,jonh@gmail.com,1122) ((John, john@gmail.com, 1122), (John_Hand, john@gmail.com, 1122))
- [ ] B. (Jonh,jonh@gmail.com,1122),(Jonh,jonh_hand@gmail.com,1122) ((John, john@gmail.com, 1122), (John, john_hand@gmail.com, 1122))
- [ ] C. (Jonh,jonh@gmail.com,1122),(Jonh_Hand,jonh@gmail.com,3344) ((John, john@gmail.com, 1122), (John_Hand, john@gmail.com, 3344))
- [x] **D. (Jonh,jonh@gmail.com,1122),(Jonh,jonh@gmail.com,3344) ((John, john@gmail.com, 1122), (John, john@gmail.com, 3344))**

> **해설**
> **Answer:** D
> Name과 Email 필드에 대해 고유 인덱스(Unique Index)를 생성하면, 동일한 Name과 Email 조합이
> 삽입될 때 오류가 발생합니다. 옵션 D에서는 `(Jonh, jonh@gmail.com)`이 두 번 삽입되므로 고유
> 제약 조건을 위반하여 오류가 발생합니다. 따라서 정답은 **D.
> (Jonh,jonh@gmail.com,1122),(Jonh,jonh@gmail.com,3344)**입니다.

---

## 문제 22

Regarding exposing elements in Producer modules... (Producer 모듈의 요소를 노출(Expose)하는 것과 관련하여...)

- [ ] A. Any element can be exposed, and reused, but only by modules of the same application. (모든 요소를 노출하고 재사용할 수 있지만 동일한 애플리케이션의 모듈에서만 가능합니다.)
- [ ] B. Any element can be exposed, and reused by modules of any application. (모든 요소를 노출하고 어떤 애플리케이션의 모듈에서도 재사용할 수 있습니다.)
- [x] **C. Only elements with the Public property set to Yes can be exposed and reused by modules of any application. (Public 속성이 Yes로 설정된 요소만 어떤 애플리케이션의 모듈에서도 노출 및 재사용할 수 있습니다.)**
- [ ] D. Only elements with the Public property set to Yes can be exposed and reused, but only by modules of the same application. (Public 속성이 Yes로 설정된 요소만 노출 및 재사용할 수 있지만 동일한 애플리케이션의 모듈에서만 가능합니다.)

> **해설**
> **Answer:** C
> Producer 모듈에서 요소를 노출(Expose)하려면 해당 요소의 Public 속성이 Yes로 설정되어야 합니
> 다. Public으로 설정된 요소는 동일 애플리케이션뿐만 아니라 다른 애플리케이션의 모듈에서도 재
> 사용할 수 있습니다. 따라서 정답은 **C. Only elements with the Public property set to Yes can be
> exposed and reused by modules of any application**입니다.

---

## 문제 23

To restrict access to a Web Screen... (웹 화면에 대한 액세스를 제한하려면...)

- [ ] A. Go to the Users application and associate the Web Screen to a specific role. (Users 애플리케이션으로 이동하여 웹 화면을 특정 역할에 연결합니다.)
- [x] **B. Select the Role in the Web Screen Properties pane and OutSystems will automatically check the Role at runtime. (웹 화면 속성 창에서 역할을 선택하면 OutSystems가 런타임에 자동으로 역할을 확인합니다.)**

> **해설**
> **Answer:** B
> Web Screen의 접근을 제한하려면 Web Screen 속성 패널에서 특정 역할(Role)을 선택하면 됩니다.
> OutSystems는 런타임에 해당 역할을 자동으로 확인하여 접근을 제어합니다. 따라서 정답은 **B.
> Select the Role in the Web Screen Properties pane and OutSystems will automatically check the
> Role at runtime**입니다.

---

## 문제 24

A Theme defines the look and feel of application Screens and you can directly apply it to ... (Theme은 애플리케이션 화면의 모양과 느낌을 정의하며, 다음에 직접 적용할 수 있습니다...)

- [ ] A. A Module, a UI Flow, or an individual Screen or Web Block. (모듈, UI Flow 또는 개별 화면이나 Web Block.)
- [ ] B. A Module, a UI Flow, or an individual Screen. (모듈, UI Flow 또는 개별 화면.)
- [x] **C. A Module or a UI Flow. (모듈 또는 UI Flow.)**
- [ ] D. Only the Module. (모듈에만.)

> **해설**
> **Answer:** C
> OutSystems에서 Theme은 애플리케이션의 모양과 느낌을 정의하며, Module 또는 UI Flow에 직접
> 적용할 수 있습니다. 개별 Screen이나 Web Block에는 직접 적용되지 않고, Module 또는 UI Flow
> 의 Theme 설정을 따릅니다. 따라서 정답은 **C. A Module or a UI Flow**입니다.

---

## 문제 25

Regarding property Escape Content of Expression, which of the following options is true? (Expression of Escape Content 속성에 대해 다음 중 옳은 것은 무엇입니까?)

- [x] **A. When set to No, the result returns exactly as the result of the formula (No로 설정된 경우 결과는 공식의 결과와 똑같이 반환됩니다.)**
- [ ] B. When set to Yes, the result returns exactly as the result of the formula (Yes로 설정된 경우 결과는 공식의 결과와 똑같이 반환됩니다.)
- [ ] C. When the value is No, the special characters in the returned result have been replaced by characters that do not affect the protocol being used. (값이 No인 경우 반환된 결과의 특수 문자는 사용 중인 프로토콜에 영향을 주지 않는 문자로 대체되었습니다.)
- [ ] D. The default value is No (기본값은 No입니다.)

> **해설**
> **Answer:** A
> Expression의 Escape Content 속성은 출력 결과의 특수 문자를 처리하는 방식을 정의합니다.
> **No**로 설정하면 결과는 공식 그대로 반환되며, 특수 문자가 이스케이프되지 않습니다. **Yes**
> 로 설정하면 특수 문자가 프로토콜에 영향을 주지 않도록 이스케이프됩니다. 따라서 정답은 **A.
> When set to No, the result returns exactly as the result of the formula**입니다.

---

## 문제 26

Regarding Session Variable, which of the following options is true? (세션 변수(Session Variable)에 대해 다음 중 옳은 것은 무엇입니까?)

- [ ] A. Set persistent property to true, the session can be shared for the entire system to use (Persistent 속성을 true로 설정하면 세션이 전체 시스템에서 사용될 수 있도록 공유될 수 있습니다.)
- [ ] B. Session variables can only use basic data types (Integer, Text, Boolean,...) (세션 변수는 기본 데이터 유형(정수, 텍스트, 불리언 등)만 사용할 수 있습니다.)
- [x] **C. The session variable will expire when the session times out (세션이 타임아웃되면 세션 변수가 만료됩니다.)**
- [ ] D. Set Cache property to store session value after user log out (로그아웃 후에 세션 값을 저장하려면 Cache 속성을 설정합니다.)

> **해설**
> **Answer:** C
> 세션 변수(Session Variable)는 사용자의 세션이 유지되는 동안 데이터를 저장하는 데 사용됩니다.
> 세션이 만료되면 세션 변수도 함께 사라집니다. Persistent 속성은 데이터베이스 저장과 관련이 있
> 으며, Cache 속성은 세션 변수와 관련이 없습니다. 따라서 정답은 **C. The session variable will
> expire when the session times out**입니다.

---

## 문제 27

To create a List screen and then a Detail screen... (목록 화면(List screen)을 만든 다음 상세 화면(Detail screen)을 만들려면...)

- [ ] A. Drag and drop an Entity to the UI Flow and it automatically creates the List and Detail Screens. (엔티티를 UI Flow로 드래그 앤 드롭하면 목록 화면과 상세 화면이 자동으로 생성됩니다.)
- [x] **B. Drag and drop an Entity to the UI Flow to create the List Screen and repeat it to create the Detail Screen. (엔티티를 UI Flow로 드래그 앤 드롭하여 목록 화면을 생성하고, 상세 화면을 생성하기 위해 이 과정을 반복합니다.)**

> **해설**
> **Answer:** B
> OutSystems에서 List Screen과 Detail Screen을 생성하려면, UI Flow에 엔티티를 드래그 앤 드롭하
> 여 List Screen을 먼저 생성하고, 동일한 과정을 반복하여 Detail Screen을 생성해야 합니다. 자동으
> 로 두 화면이 동시에 생성되지는 않습니다. 따라서 정답은 **B. Drag and drop an Entity to the UI
> Flow to create the List Screen and repeat it to create the Detail Screen**입니다.

---

## 문제 28

In any case, should use Site property (어떤 경우에 Site 속성을 사용해야 합니까?)

- [x] **A. Minimum password length (최소 비밀번호 길이)**
- [ ] B. Number of logged user (로그인한 사용자 수)
- [ ] C. Search field value (검색 필드 값)

> **해설**
> **Answer:** A
> Site 속성은 애플리케이션 전반에 걸쳐 사용되는 전역 설정을 정의하는 데 사용됩니다. 예를 들어,
> **Minimum password length**는 모든 사용자에게 적용되는 보안 정책으로 Site 속성에 적합합니
> 다. 반면, 로그인한 사용자 수나 검색 필드 값은 동적 데이터로 Site 속성에 적합하지 않습니다.
> 따라서 정답은 **A. Minimum password length**입니다.

---

## 문제 29

A Structure can have attributes of the following data types: (Structure는 다음과 같은 데이터 유형의 속성을 가질 수 있습니다:)

- [ ] A. Basic, Complex, and Record (기본, 복합 및 레코드)
- [ ] B. Basic, String, and Object (기본, 문자열 및 객체)
- [x] **C. Basic, Structure, Entity, and List (기본, 구조체, 엔티티 및 리스트)**
- [ ] D. Basic and List only (기본 및 리스트 전용)

> **해설**
> **Answer:** C
> OutSystems에서 Structure는 다양한 데이터 타입의 속성을 가질 수 있습니다. 지원되는 데이터 타
> 입은 기본 타입(Basic), Structure, Entity, List입니다. Complex나 Object는 OutSystems에서 사용되지
> 않는 용어입니다. 따라서 정답은 **C. Basic, Structure, Entity, and List**입니다.

---

## 문제 30

What types of applications can be created in OutSystems? (OutSystems에서 어떤 유형의 애플리케이션을 생성할 수 있습니까?)

- [x] **A. Web, Mobile and Service (웹, 모바일 및 서비스)**
- [ ] B. Web, Mobile, Service and Extension (웹, 모바일, 서비스 및 익스텐션)
- [ ] C. Module and Extension (모듈 및 익스텐션)
- [ ] D. Only Web (웹 전용)

> **해설**
> **Answer:** A
> OutSystems에서는 Web, Mobile, Service 애플리케이션을 생성할 수 있습니다. Extension은 별도의
> 모듈 타입으로 간주되지 않으며, Module은 애플리케이션의 구성 요소일 뿐입니다. 따라서 정답은
> **A. Web, Mobile and Service**입니다.

---

## 문제 31

Style load order (스타일 로드 순서)

- [ ] A. Screen & Email -> Web block -> theme (화면 및 이메일 -> Web block -> Theme)
- [ ] B. theme -> Web block -> Screen & Email (Theme -> Web block -> 화면 및 이메일)
- [x] **C. Web block -> theme -> Screen & Email (Web block -> Theme -> 화면 및 이메일)**

> **해설**
> **Answer:** C
> OutSystems에서 스타일 로드 순서는
> 1. System style sheet for Container widgets in the Grid.
> 2. Block style sheet.
> 3. Theme style sheet, which also includes a base theme (if specified).
> 4. Screen or Email style sheet.
> 5. Theme extra style sheet, with the Grid settings defined in the Theme properties.
> 6. Styles that Service Studio generates when you use Styles Editor.
> 7. Inline style you define in Attributes or Extended Properties.

---

## 문제 32

Regarding Preparation in Outsystems, select to statement that is true. (OutSystems의 Preparation에 대해 옳은 문장을 선택하세요.)

- [ ] A. Preparation action may have multiple outputs (Preparation 액션은 여러 출력을 가질 수 있습니다.)
- [ ] B. Preparation is a forced action of Screen and webBlock (Preparation은 화면 및 webBlock의 필수 액션입니다.)
- [ ] C. The preparation action can only have 1 output (Preparation 액션은 하나의 출력만 가질 수 있습니다.)
- [x] **D. Screen may not need Preparation (화면은 Preparation이 필요하지 않을 수 있습니다.)**

> **해설**
> **Answer:** D
> Preparation 액션은 Screen 또는 Web Block이 렌더링되기 전에 데이터를 준비하는 데 사용됩니다.
> 하지만 모든 Screen이 Preparation 액션을 필요로 하지는 않습니다. Preparation 액션은 여러 출력
> 매개변수를 가질 수 있으며, 필수 액션은 아닙니다. 따라서 정답은 **D. Screen may not need
> Preparation**입니다.

---

## 문제 33

Roles are created in applications and user authorizations are managed... (애플리케이션에서 역할(Role)이 생성되고 사용자 권한이 관리됩니다...)

- [x] **A. Manually in the Users application or programmatically. (Users 애플리케이션에서 수동으로 또는 프로그래밍 방식으로.)**
- [ ] B. Only manually in the Users application. (Users 애플리케이션에서 수동으로만.)
- [ ] C. Only programmatically using the Grant... and Revoke... role actions. (Grant... 및 Revoke... 역할 액션을 사용하여 프로그래밍 방식으로만.)

> **해설**
> **Answer:** A
> OutSystems에서 역할(Role)은 애플리케이션 내에서 생성되며, 사용자 권한은 Users 애플리케이션
> 을 통해 수동으로 관리하거나, Grant 및 Revoke 역할 액션을 사용하여 프로그래밍적으로 관리할
> 수 있습니다. 따라서 정답은 **A. Manually in the Users application or programmatically**입니다.

---

## 문제 34

When consuming a REST service, what callback action should be used to customize a request sent to the external service? (REST 서비스를 소비할 때 외부 서비스로 전송되는 요청을 사용자 정의하기 위해 어떤 콜백 액션을 사용해야 합니까?)

- [ ] A. On Consume (On Consume)
- [x] **B. On Before Request (On Before Request)**
- [ ] C. On After Response (On After Response)
- [ ] D. On REST Request (On REST Request)

> **해설**
> **Answer:** B
> REST 서비스를 소비할 때 요청을 커스터마이징하려면 **On Before Request** 콜백 액션을 사용해
> 야 합니다. 이 액션은 요청이 외부 서비스로 전송되기 전에 실행되어 요청 헤더나 페이로드를 수
> 정할 수 있습니다. 따라서 정답은 **B. On Before Request**입니다.

---

## 문제 35

When there is a change in the Producer module, which statement later about the Consumer module is correct. (Producer 모듈에 변경 사항이 있을 때, Consumer 모듈에 대한 설명으로 옳은 것은 무엇입니까?)

- [x] **A. When adding the output of Server action, the consumer will get an error if the Producer is not updated (서버 액션의 출력을 추가할 때 Producer가 업데이트되지 않으면 Consumer에서 오류가 발생합니다.)**
- [ ] B. When changing the internal logic of a server action without changing the input-output, Consumer still uses the latest logic (입출력을 변경하지 않고 서버 액션의 내부 로직을 변경할 때 Consumer는 여전히 최신 로직을 사용합니다.)
- [ ] C. When deleting the input of the Server action, the consumer will get an error if the Producer is not updated (서버 액션의 입력을 삭제할 때 Producer가 업데이트되지 않으면 Consumer에서 오류가 발생합니다.)
- [ ] D. When changing the content of the web screen, the Consumer is still not affected even without updating Producer (웹 화면의 콘텐츠를 변경할 때 Consumer는 Producer를 업데이트하지 않아도 영향을 받지 않습니다.)

> **해설**
> **Answer:** A
> Producer 모듈에서 서버 액션의 출력 매개변수를 추가하면, Consumer 모듈은 Producer가 업데이
> 트되지 않으면 참조 오류가 발생합니다. 내부 로직 변경은 입력-출력이 동일하다면 영향을 주지
> 않으며, 웹 화면 변경은 Consumer에 직접적인 영향을 주지 않습니다. 따라서 정답은 **A. When
> adding the output of Server action, the consumer will get an error if the Producer is not updated**
> 입니다.

---

## 문제 36

Inside the Preparation of Web Screen, the Destination statement... (웹 화면의 Preparation 내에서 Destination 문은...)

- [ ] A. . cannot be used.
- [x] **B. allows redirecting the user to a different Web Screen, without rendering the current Screen. (현재 화면을 렌더링하지 않고 사용자를 다른 웹 화면으로 리디렉션할 수 있습니다.)**
- [ ] C. renders the Current Screen and afterwards the users is redirected to the Destination Screen. (현재 화면을 렌더링한 후 사용자가 Destination 화면으로 리디렉션됩니다.)
- [ ] D. prompts the user before redirecting to the Destination Web Screen (Destination 웹 화면으로 리디렉션하기 전에 사용자에게 확인 메시지를 표시합니다.)

> **해설**
> **Answer:** B
> Web Screen의 Preparation에서 Destination 문은 현재 화면을 렌더링하지 않고 사용자를 다른 화
> 면으로 리디렉션합니다. 이는 조건에 따라 즉시 다른 화면으로 이동할 때 사용됩니다. 따라서 정
> 답은 **B. allows redirecting the user to a different Web Screen, without rendering the current
> Screen**입니다.

---

## 문제 37

Consider that you want to change your application Header, with new fonts, colors and an icon. What is the best approach to accomplish that in Outsystems? (새로운 글꼴, 색상 및 아이콘으로 애플리케이션 헤더를 변경하고 싶다고 가정해 보세요. OutSystems에서 이를 달성하기 위한 가장 좋은 방법은 무엇입니까?)

- [ ] A. Change the Common/Header Web Block, by adding a Container with the new icon. Add the new CSS to the Module Theme's Style Sheet. (새 아이콘이 있는 컨테이너를 추가하여 Common/Header Web Block을 변경합니다. 모듈 Theme의 스타일 시트에 새 CSS를 추가합니다.)
- [ ] B. Add the new CSS to the Style Sheet of every Web Screens in the application, overriding the Style Sheet of the Common/Header Web Block Replace the Header_Logo with the new icon. (애플리케이션의 모든 웹 화면 스타일 시트에 새 CSS를 추가하고 Common/Header Web Block의 스타일 시트를 무시하며 Header_Logo를 새 아이콘으로 교체합니다.)
- [x] **C. Change the Style Sheet of the Common/Header Web Block, with the new CSS implemented and replace the Header_Logo with the new icon. (새 CSS가 구현된 상태에서 Common/Header Web Block의 스타일 시트를 변경하고 Header_Logo를 새 아이콘으로 교체합니다.)**
- [ ] D. Replace the Common/Header Web Block on every Web Screen with a new Web Block containing the new icon and CSS in its Style Sheet. (모든 웹 화면의 Common/Header Web Block을 새 아이콘과 CSS가 포함된 새 Web Block으로 교체합니다.)

> **해설**
> **Answer:** C
> 애플리케이션의 헤더를 변경하려면 공통적으로 사용되는 **Common/Header Web Block**의 스타
> 일 시트(Style Sheet)를 수정하고, 로고(Header_Logo)를 새로운 아이콘으로 교체하는 것이 가장 효
> 율적입니다. 모든 화면에 개별적으로 CSS를 추가하거나 Web Block을 교체하는 것은 비효율적입
> 니다. 따라서 정답은 **C. Change the Style Sheet of the Common/Header Web Block, with the new
> CSS implemented and replace the Header_Logo with the new icon**입니다.

---

## 문제 38

XXX screen only Registered role is checked, which of the following statements is true? (XXX 화면에 Registered 역할만 체크되어 있는 경우, 다음 중 옳은 것은 무엇입니까?)

- [x] **A. User has not logged in, make request Screen XXX. As a result, can not permission (사용자가 로그인하지 않고 XXX 화면을 요청했습니다. 결과적으로 권한을 가질 수 없습니다.)**
- [ ] B. User logged, make request Screen XXX. As a result, can not permission (사용자가 로그인했지만 XXX 화면을 요청했습니다. 결과적으로 권한을 가질 수 없습니다.)

> **해설**
> **Answer:** A
> XXX 화면에 **Registered** 역할만 체크되어 있다면, 해당 화면에 접근하려면 사용자가 로그인하
> 여 Registered 역할을 가져야 합니다. 로그인하지 않은 사용자가 요청하면 권한이 없어 접근할 수
> 없습니다. 따라서 정답은 **A. User has not logged in, make request Screen XXX. As a result, can
> not permission**입니다.

---

## 문제 39

Regarding a Consumer module (Consumer 모듈과 관련하여)

- [ ] A. It can only reuse elements from Producer modules of the same application. (동일한 애플리케이션의 Producer 모듈 요소만 재사용할 수 있습니다.)
- [x] **B. It can only reuse elements that are Public in their Producer modules. (Producer 모듈에서 Public으로 설정된 요소만 재사용할 수 있습니다.)**
- [ ] C. It can reuse any element from any Producer module. (모든 Producer 모듈의 모든 요소를 재사용할 수 있습니다.)
- [ ] D. It can only reuse elements from Producer modules of other applications. (다른 애플리케이션의 Producer 모듈 요소만 재사용할 수 있습니다.)

> **해설**
> **Answer:** B
> Consumer 모듈은 Producer 모듈의 요소를 재사용할 수 있지만, 해당 요소가 **Public**으로 설정
> 되어 있어야 합니다. Public이 아닌 요소는 재사용할 수 없으며, 동일 애플리케이션이나 다른 애플
> 리케이션에 관계없이 Public 요소만 가능합니다. 따라서 정답은 **B. It can only reuse elements that
> are Public in their Producer modules**입니다.

---

## 문제 40

Give 1 aggregate as shown. Ask how to display the average score of the group according to Point1 and sort the order of Point 2 with the highest score by year (예시로 제시된 Aggregate가 있습니다. 그룹별 Point 1의 평균 점수를 표시하고 Point 2의 최고 점수를 연도별로 정렬하는 방법은 무엇입니까?)

- [ ] A. Use the GROUPBY function according to the Year attribute, then perform the AVERAGE function for the Point 1 attribute and MAX for the attribute for Point 2. (연도 속성에 따라 GROUPBY 함수를 사용한 다음, Point 1 속성에 대해 AVERAGE 함수를, Point 2 속성에 대해 MAX 함수를 수행합니다.)
- [x] **B. Use the GROUPBY function according to the Group attribute, then perform the AVERAGE function for the Point 1 attribute and MAX for the attribute for Point 2. (그룹 속성에 따라 GROUPBY 함수를 사용한 다음, Point 1 속성에 대해 AVERAGE 함수를, Point 2 속성에 대해 MAX 함수를 수행합니다.)**
- [ ] C. Use the GROUPBY function according to the Year attribute, then perform the AVERAGE function for the Point 2 attribute and MAX for the Point 1 attribute. (연도 속성에 따라 GROUPBY 함수를 사용한 다음, Point 2 속성에 대해 AVERAGE 함수를, Point 1 속성에 대해 MAX 함수를 수행합니다.)
- [ ] D. Use the GROUPBY function according to the Group attribute, then perform the AVERAGE function for the Point 2 attribute and MAX for the attribute for Point 1. (그룹 속성에 따라 GROUPBY 함수를 사용한 다음, Point 2 속성에 대해 AVERAGE 함수를, Point 1 속성에 대해 MAX 함수를 수행합니다.)

> **해설**
> **Answer:** B
> Aggregate를 사용하여 그룹별 평균 점수(Point1)를 표시하고, Point2의 최고 점수를 기준으로 연도
> 별 정렬하려면, **Group** 속성으로 GROUPBY를 수행한 후, Point1에 대해 AVERAGE 함수를,
> Point2에 대해 MAX 함수를 적용해야 합니다. Year로 그룹화하면 요구사항과 맞지 않습니다. 따라
> 서 정답은 **B. Use the GROUPBY function according to the Group attribute, then perform the
> AVERAGE function for the Point 1 attribute and MAX for the attribute for Point 2**입니다.

---

## 문제 41

To replace data on a widget with automatic data replacement (Tables Records, List Records, Form,...) (위젯의 데이터를 자동 데이터 교체(Table Records, List Records, Form 등)로 대체하려면...)

- [ ] A. Right-click on the widget and select Import Data from Entity (위젯을 마우스 오른쪽 버튼으로 클릭하고 엔티티에서 데이터 가져오기를 선택합니다.)
- [ ] B. Delete the widget and create it again with the right Entities. (위젯을 삭제하고 올바른 엔티티로 다시 생성합니다.)
- [x] **C. Drag your Entity and drop it onto the widget. (엔티티를 위젯 위로 드래그 앤 드롭합니다.)**
- [ ] D. Right-click on the Entity and select Import Data from Excel. (엔티티를 마우스 오른쪽 버튼으로 클릭하고 엑셀에서 데이터 가져오기를 선택합니다.)

> **해설**
> **Answer:** C
> OutSystems에서 Table Records, List Records, Form 등의 위젯에 데이터를 자동으로 교체하려면, 엔
> 티티(Entity)를 위젯 위로 드래그 앤 드롭하면 됩니다. 이는 데이터를 위젯에 바인딩하는 가장 직
> 관적이고 효율적인 방법입니다. 따라서 정답은 **C. Drag your Entity and drop it onto the widget**
> 입니다.

---

## 문제 42

When an OnParameterChange event will trigger? (OnParameterChange 이벤트는 언제 트리거됩니까?)

- [ ] A. When the block changes the value of any input parameter of itself. (블록이 자신의 입력 매개변수 값을 변경할 때.)
- [ ] B. When the parent of the block or block itself changes the value of the block's input parameter. (블록의 부모나 블록 자체가 블록의 입력 매개변수 값을 변경할 때.)
- [x] **C. When the parent of the block changes the value of any of the block's input parameters. (블록의 부모가 블록의 입력 매개변수 값을 변경할 때.)**
- [ ] D. If the value of a Block's Input Parameters changes inside a Client Action of the Block. (블록의 클라이언트 액션 내부에서 블록의 입력 매개변수 값이 변경되는 경우.)

> **해설**
> When the parent of the block changes the value of any of the block's input parameters.
> OnParameterChange will only trigger when any of block's input parameter value is changed from
> parent of block. Parent can be both screen or other block.
> `OnParameterChange` 이벤트는 블록의 입력 매개변수 값이 부모(화면 또는 다른 블록)에 의해 변
> 경될 때만 트리거됩니다. 따라서 정답은 **"When the parent of the block changes the value of any
> of the block's input parameters."**입니다. 블록 자체가 값을 변경하거나 클라이언트 액션 내부에서
> 값이 변경되는 경우에는 이벤트가 발생하지 않습니다.

---

## 문제 43

If in an entity, a reference attribute is defined with protect rule then what is the correct statement? (엔티티에서 참조 속성이 Protect 규칙으로 정의된 경우 올바른 설명은 무엇입니까?)

- [x] **A. It would not allow deleting rows from the parent entity in case of reference data is available in the child table. (자식 테이블에 참조 데이터가 있는 경우 부모 엔티티에서 행을 삭제할 수 없습니다.)**
- [ ] B. It would protect entities from cyber attacks. (사이버 공격으로부터 엔티티를 보호합니다.)
- [ ] C. It would not allow deletion row from the parent table in every case. (모든 경우에 부모 테이블에서 행을 삭제할 수 없습니다.)
- [ ] D. It would protect the entity to perform a delete operation on itself. (자체적으로 삭제 작업을 수행하도록 엔티티를 보호합니다.)

> **해설**
> It would not allow deleting rows from the parent entity in case of reference data is
> available in the child table.
> 엔터티에서 참조 속성이 `Protect` 규칙으로 정의된 경우, 자식 테이블에 참조 데이터가 존재하면
> 부모 엔터티의 행을 삭제할 수 없습니다. 이는 참조 무결성을 유지하기 위한 제약입니다.

---

## 문제 44

Which of the following is not possible to fetch when the screen is initializing? (화면이 초기화될 때 다음 중 가져올 수 없는 것은 무엇입니까?)

- [x] **A. Advanced SQL in the screen level (화면 수준에서의 Advanced SQL)**
- [ ] B. Aggregates in the screen level. (화면 수준에서의 Aggregate)
- [ ] C. Aggregates inside the data action flow (데이터 액션 흐름 내의 Aggregate)
- [ ] D. Rest API in the data action flow. (데이터 액션 흐름 내의 Rest API)

> **해설**
> Advanced SQL in the screen level
> Advanced SQL can only be used in server action or Inside Data Actions.
> 화면 초기화 시, `Advanced SQL`은 화면 수준에서 직접 가져올 수 없으며, 서버 액션이나 데이터
> 액션 내에서만 사용할 수 있습니다. 반면, 화면 수준의 `Aggregates`, 데이터 액션 흐름 내의
> `Aggregates`, 그리고 `Rest API`는 초기화 시 가져올 수 있습니다

---

## 문제 45

Why should we not call multiple server actions in one client action? (하나의 클라이언트 액션에서 여러 서버 액션을 호출하면 안 되는 이유는 무엇입니까?)

- [ ] A. Because there is a risk of cyber-attacks? (사이버 공격의 위험이 있기 때문입니까?)
- [x] **B. It gives a performance problem and may slow down the application processing (성능 문제를 일으키고 애플리케이션 처리 속도를 늦출 수 있습니다.)**
- [ ] C. It can cause incorrect data operation. (잘못된 데이터 작업을 유발할 수 있습니다.)
- [ ] D. It can cause data issues. (데이터 문제를 유발할 수 있습니다.)

> **해설**
> It gives a performance problem and may slow down the application processing
> Calling multiple server action may slow down the application processing as it gives multiple call to
> server which gives performance troubles.
> 클라이언트 액션에서 여러 서버 액션을 호출하면 서버에 다중 호출이 발생하여 성능 문제가 발생
> 하고 애플리케이션 처리 속도가 느려질 수 있습니다.

---

## 문제 46

Choose the correct option associated with the below ERD? (아래 ERD와 관련된 올바른 옵션을 선택하세요.)

- [x] **A. OrderType Can not have SellOrderId attribute (OrderType은 SellOrderId 속성을 가질 수 없습니다.)**
- [ ] B. No mapping can be formed between both entities. (두 엔티티 사이에 매핑을 형성할 수 없습니다.)
- [ ] C. OrderType should be a normal entity. (OrderType은 일반 엔티티여야 합니다.)
- [ ] D. SellOrder can not have OrderType attribute. (SellOrder는 OrderType 속성을 가질 수 없습니다.)

> **해설**
> OrderType Can not have SellOrderId attribute
> A normal Entity's identifier cannot be referenced in a Static entity.
> 정적 엔터티(Static Entity)는 일반 엔터티(Normal Entity)의 식별자를 참조 속성으로 가질 수 없습니
> 다. 이는 OutSystems의 정적 엔터티가 고정된 데이터만 포함하며, 동적 참조를 허용하지 않는 설
> 계 제약 때문입니다.

---

## 문제 47

Is it possible to define entity identifier other then LongInteger data type? (LongInteger 데이터 유형 이외의 엔티티 식별자를 정의할 수 있습니까?)

- [ ] A. Yes (예)
- [ ] B. No (아니요)
- [x] **C. Yes, But it can be only Text, Integer, LongInteger, and Entity Identifier (예, 하지만 텍스트, 정수, LongInteger 및 엔티티 식별자만 가능합니다.)**
- [ ] D. Yes, but it can be only EntityIdentifier (예, 하지만 엔티티 식별자만 가능합니다.)

> **해설**
> Yes, But it can be only Text, Integer, LongInteger, and Entity Identifier
> Entity Identifier can be set as Text, Integer, Long Integer, and Other Entity Identifier
> OutSystems에서 엔터티 식별자는 `LongInteger`뿐만 아니라 `Text`, `Integer`, `LongInteger`, 그리고
> 다른 엔터티 식별자로 설정할 수 있습니다. 따라서 정답은 **"Yes, But it can be only Text, Integer,
> LongInteger, and Entity Identifier"**입니다.

---

## 문제 48

Which of the following is true about the 'On Render' event? ('On Render' 이벤트에 대해 다음 중 옳은 것은 무엇입니까?)

- [ ] A. It triggered before the onReady event. (onReady 이벤트 이전에 트리거됩니다.)
- [ ] B. It is the first event to be triggered when we navigate from one screen to other. (한 화면에서 다른 화면으로 이동할 때 트리거되는 첫 번째 이벤트입니다.)
- [x] **C. It runs every time when there is any change in the data on the screen. (화면 데이터에 변경 사항이 있을 때마다 실행됩니다.)**
- [ ] D. It runs only once after the page is ready. (페이지가 준비된 후 한 번만 실행됩니다.)

> **해설**
> It runs every time when there is any change in the data on the screen.
> OnRender event triggered every time when there is any change in the data on the screen.
> OutSystems에서 `On Render` 이벤트는 화면의 렌더링이 완료된 후 발생하며, `OnReady` 이벤트(화
> 면의 모든 요소가 준비된 후)보다 **나중에** 트리거됩니다.

---

## 문제 49

Which statement about entities is false? (엔티티에 대한 설명 중 틀린 것은 무엇입니까?)

- [ ] A. Entities do not require an Identifier (엔티티는 식별자가 필요하지 않습니다.)
- [ ] B. Entities can be deleted (엔티티는 삭제될 수 있습니다.)
- [ ] C. Entities can be set as multitenant (엔티티는 멀티테넌트로 설정될 수 있습니다.)
- [x] **D. Entities are stored in memory (엔티티는 메모리에 저장됩니다.)**

> **해설**
> Entities are stored in memory
> 엔터티는 데이터베이스에 테이블로 저장되며, 메모리에 저장되지 않습니다. 따라서 **"Entities are
> stored in memory"**는 거짓입니다. 엔터티는 식별자를 필요로 하며, 삭제 가능하고, 멀티테넌트로
> 설정할 수 있습니다.

---

## 문제 50

Which of the option below is true when any of the mandatory input's valid property is false? (필수 입력의 Valid 속성이 false인 경우 다음 중 옳은 것은 무엇입니까?)

- [ ] A. Form.valid will be true. (Form.valid가 true가 됩니다.)
- [ ] B. We would require to set form.valid property false explicitly. (form.valid 속성을 명시적으로 false로 설정해야 합니다.)
- [ ] C. Form.valid will be unchanged. (Form.valid가 변경되지 않습니다.)
- [x] **D. The form's valid property will automatically be set to false. (폼의 valid 속성이 자동으로 false로 설정됩니다.)**

> **해설**
> The form's valid property will automatically be set to false.
> 필수 입력 필드의 `Valid` 속성이 `False`인 경우, 폼 전체의 `Valid` 속성도 자동으로 `False`로 설정
> 됩니다. 이는 OutSystems의 폼 유효성 검사 메커니즘 때문입니다. 따라서 정답은 **"valid
> property will automatically be set to false."**입니다.

---

## 문제 51

A client action is set to its public and function property set to "NO", This action can be.... (클라이언트 액션의 Public 및 Function 속성이 "NO"로 설정된 경우, 이 액션은...)

- [x] **A. Can be called a Screen Action. (화면 액션(Screen Action)으로 호출될 수 있습니다.)**
- [ ] B. Can be called from a Server Action. (서버 액션(Server Action)에서 호출될 수 있습니다.)
- [ ] C. Can be used in an Expression (Expression에서 사용할 수 있습니다.)
- [ ] D. Can be called from other modules. (다른 모듈에서 호출될 수 있습니다.)

> **해설**
> Can be called a Screen Action.
> If function property set to yes than only it can be called in an expression, and if public property is
> set to be yes then only it can be called from other module. And client action can not be called from
> server action.
> 클라이언트 액션의 `Public` 속성이 `No`이고 `Function` 속성이 `No`인 경우, 해당 액션은 다른 모
> 듈에서 호출될 수 없습니다. `Function` 속성이 `No`이므로 표현식(Expression)에서 호출할 수 없으
> 며, 클라이언트 액션은 서버 액션에서 호출될 수 없습니다.

---

## 문제 52

What would be the value of FinalValue in the below logic? (아래 로직에서 FinalValue의 값은 무엇이 됩니까?)

- [x] **A. FinalValue will be the default value or equal to the 'Value'. (FinalValue는 기본값이거나 'Value'와 같습니다.)**
- [ ] B. The FinalValue will be the default value assigned to it. (FinalValue는 할당된 기본값입니다.)
- [ ] C. The value of FinalValue is always 5. (FinalValue의 값은 항상 5입니다.)
- [ ] D. The value of the FinalValue will be greater than 5. (FinalValue의 값은 5보다 큽니다.)

> **해설**
> FinalValue will be the default value or equal to the 'Value'.
> 최종값은 Value와 FinalValue 가 다를 수 있으나 다른 선택지가 모두 오답이고 일시적으로는 같은
> 값으로 설정 될 것임.

---

## 문제 53

When the built-in validation is set to true, in which condition form will be submitted? (내장 유효성 검사(Built-in validation)가 true로 설정된 경우, 폼은 어떤 조건에서 제출됩니까?)

- [ ] A. When the Integer field, is filled with a Text value. (정수 필드가 텍스트 값으로 채워진 경우.)
- [x] **B. When all non-mandatory fields are not filled. (필수 항목이 아닌 모든 필드가 채워지지 않은 경우.)**
- [ ] C. When the date filed is filled with an Integer value. (날짜 필드가 정수 값으로 채워진 경우.)
- [ ] D. When some of the mandatory fields are not filled. (일부 필수 필드가 채워지지 않은 경우.)

> **해설**
> When all non-mandatory fields are not filled.
> When built-in validation is set to true in that case all the mandatory fields should be correctly filled.
> `Built-in Validation`이 `True`로 설정된 경우, 폼은 모든 필수 필드가 올바르게 채워졌을 때만 제출
> 됩니다. 따라서 잘못된 데이터 유형(예: Integer 필드에 Text 값)이나 필수 필드가 채워지지 않은
> 경우 폼은 제출되지 않습니다.

---

## 문제 54

If there are 2 entities, User and UserDetail. If one UserDetail belongs to only one User, how can we create the one-to-One mapping between them? (User와 UserDetail 두 엔티티가 있습니다. 하나의 UserDetail이 하나의 User에만 속하는 경우, 이들 간의 일대일 매핑을 어떻게 생성할 수 있습니까?)

- [ ] A. Make the datatype the primary key of the User entity to UserDetail Identifier. (User 엔티티의 기본 키 데이터 유형을 UserDetail 식별자로 만듭니다.)
- [ ] B. Add a new attribute in UserDetail and make its data type User Identifier. (UserDetail에 새 속성을 추가하고 데이터 유형을 User 식별자로 만듭니다.)
- [ ] C. Add a new attribute in User and make its data type as UserDetail Identifier. (User에 새 속성을 추가하고 데이터 유형을 UserDetail 식별자로 만듭니다.)
- [x] **D. Make the Datatype of the primary key of the UserDetail entity to User Identifier. (UserDetail 엔티티의 기본 키 데이터 유형을 User 식별자로 만듭니다.)**

> **해설**
> Make the Datatype of the primary key of the UserDetail entity to User Identifier.
> If the Primary Key of one Entity is the primary key of another entity then it forms One to One
> Mapping.
> 일대일 매핑을 만들기 위해, `UserDetail` 엔터티의 기본 키를 `User` 엔터티의 식별자(`User
> Identifier`)로 설정해야 합니다. 이렇게 하면 `UserDetail`의 각 레코드가 정확히 하나의 `User` 레코
> 드와 연결됩니다.

---

## 문제 55

We need to check if a specific element is present in the list, which list method would be used? (리스트에 특정 요소가 있는지 확인해야 할 때 어떤 리스트 메서드를 사용합니까?)

- [ ] A. ListIndexOf (ListIndexOf)
- [ ] B. ListFilter (ListFilter)
- [x] **C. ListAny (ListAny)**
- [ ] D. ListContains (ListContains)

> **해설**
> ListAny
> ListAny will check if it contains element which justify the given condition. If present it would return
> true else false.
> 리스트에 특정 요소가 있는지 확인하려면 `ListAny` 메서드를 사용합니다. 이 메서드는 주어진 조
> 건을 만족하는 요소가 리스트에 있는지 확인하여 `True` 또는 `False`를 반환합니다.

---

## 문제 56

Which of the following can be set as a datatype of site property? (다음 중 Site 속성의 데이터 유형으로 설정할 수 있는 것은 무엇입니까?)

- [ ] A. Structure (Structure)
- [ ] B. List (List)
- [x] **C. Entity Identifier (Entity Identifier)**
- [ ] D. Binary (Binary)

> **해설**
> Entity Identifier
> Site Property Data Type can be set to any basic data type (except binary) and Entity Identifier.
> 사이트 속성(Site Property)의 데이터 유형은 기본 데이터 유형(예: Text, Integer 등)과 `Entity
> Identifier`로 설정할 수 있지만, `Binary`는 지원되지 않습니다. `Structure`와 `List`도 사이트 속성으
> 로 직접 설정할 수 없습니다.

---

## 문제 57

Which programming concept is similar to the static entity? (어떤 프로그래밍 개념이 정적 엔티티(Static Entity)와 유사합니까?)

- [ ] A. Object (객체)
- [ ] B. Map (맵)
- [ ] C. Collection (컬렉션)
- [x] **D. Enumeration (열거형(Enumeration))**

> **해설**
> Enumeration
> 정적 엔터티(Static Entity)는 고정된 데이터 집합을 나타내며, 이는 프로그래밍에서
> `Enumeration`(열거형)과 유사합니다. `Enumeration`은 미리 정의된 상수 값의 집합을 나타냅니다.

---

## 문제 58

On which type of variable we can apply for each loop? (어떤 유형의 변수에 For Each 루프를 적용할 수 있습니까?)

- [x] **A. List (List)**
- [ ] B. Entity Identifier (Entity Identifier)
- [ ] C. Integer (정수)
- [ ] D. Structure (Structure)

> **해설**
> List
> In OutSystems, for each loop can be applied only on List type of variables
> OutSystems에서 `For Each` 루프는 `List` 유형의 변수에만 적용할 수 있습니다. `Entity Identifier`,
> `Integer`, `Structure`는 루프를 적용할 수 없습니다.

---

## 문제 59

What is wrong in respect of the LINK widget onClick event? (LINK 위젯의 onClick 이벤트와 관련하여 잘못된 것은 무엇입니까?)

- [ ] A. It can be set to an external URL (외부 URL로 설정할 수 있습니다.)
- [ ] B. It can be set to any screen in scope. (범위 내의 모든 화면으로 설정할 수 있습니다.)
- [x] **C. It can be set to public client action. (공용 클라이언트 액션으로 설정할 수 있습니다.)**
- [ ] D. It can be set to the current screen. (현재 화면으로 설정할 수 있습니다.)

> **해설**
> It can be set to public client action.
> Link's and Button OnClick event property are same. OnClick property of button and link can be set
> to 1. Current Screen 2 Previous Screen 3. Screen's Client action 4. External URL.
> 링크 위젯의 `OnClick` 이벤트는 버튼의 `OnClick` 이벤트와 동일하며, 현재 화면, 이전 화면, 화면
> 의 클라이언트 액션, 외부 URL로 설정할 수 있습니다. 그러나 **공용 클라이언트 액션(Public
> Client Action)**으로 직접 설정할 수는 없습니다. 따라서 잘못된 옵션은 **"It can be set to public
> client action."**입니다.

---

## 문제 60

What is the "function" property of client and server action? (클라이언트 및 서버 액션의 "function" 속성은 무엇입니까?)

- [ ] A. By setting it to yes, it would be publicly available (Yes로 설정하면 공개적으로 사용할 수 있습니다.)
- [ ] B. By setting it no, it would be available to consumer modules. (No로 설정하면 Consumer 모듈에서 사용할 수 있습니다.)
- [ ] C. Its scope will be global by setting it Yes (Yes로 설정하면 범위가 전역이 됩니다.)
- [x] **D. By setting yes, it would be available to call from Expression Editor (Yes로 설정하면 Expression 에디터에서 호출할 수 있습니다.)**

> **해설**
> By setting yes, it would be available to call from Expression Editor
> 클라이언트 및 서버 액션의 `Function` 속성을 `Yes`로 설정하면, 해당 액션이 표현식 편집기
> (Expression Editor)에서 호출 가능해집니다. 이는 액션을 함수처럼 사용할 수 있게 합니다.

---

## 문제 61

Which is false regarding the Static entities? (정적 엔티티(Static entities)에 대해 틀린 것은 무엇입니까?)

- [ ] A. It is available on the client side (클라이언트 측에서 사용할 수 있습니다.)
- [x] **B. Records can be created at run time (런타임에 레코드를 생성할 수 있습니다.)**
- [ ] C. It can be created at the time of development (개발 시점에 생성할 수 있습니다.)
- [ ] D. It contains records (레코드를 포함합니다.)

> **해설**
> **Answer:** B
> 정적 엔티티(Static Entity)는 개발 시점(Development time)에 레코드가 정의되며, 런타임(Runtime)에는 레코드를 생성할 수 없습니다. 따라서 'Records can be created at run time'이 틀린 설명입니다.

---

## 문제 62

What is "Expose Read Only" in respect of entity? (엔티티의 "Expose Read Only" 속성은 무엇을 의미합니까?)

- [ ] A. Only Read Only Entity Identifier can be used as a reference attribute (읽기 전용 엔티티 식별자만 참조 속성으로 사용할 수 있습니다.)
- [x] **B. It would be exposed as read-only to the consumer modules. (Consumer 모듈에 읽기 전용으로 노출됩니다.)**
- [ ] C. It is useless property (쓸모없는 속성입니다.)
- [ ] D. It would not allow to write anything in entity. (엔티티에 아무것도 쓸 수 없도록 합니다.)

> **해설**
> **Answer:** B
> 엔티티의 'Expose Read Only' 속성을 Yes로 설정하면, 해당 엔티티를 참조하는 다른 모듈(Consumer modules)에서는 데이터를 읽을 수만 있고 직접 수정(Create, Update, Delete)할 수 없게 노출됩니다.

---

## 문제 63

To ensure that the incorrect data doesn't reach the server, what is to be done? Note: Built-In validation property is set to True? (잘못된 데이터가 서버에 도달하지 않도록 하려면 어떻게 해야 합니까? (참고: Built-In validation 속성이 True로 설정됨))

- [x] **A. Form Valid property has to be checked before adding the data to the database. (데이터베이스에 데이터를 추가하기 전에 Form Valid 속성을 확인해야 합니다.)**
- [ ] B. Form Valid property has to be set to false in the action flow. (액션 흐름에서 Form Valid 속성을 false로 설정해야 합니다.)
- [ ] C. Nothing. Since the built-in validation is set to true. (아무것도 하지 않습니다. 내장 유효성 검사가 true로 설정되어 있기 때문입니다.)
- [ ] D. Appropriate logic should be written before sending data to the server. (데이터를 서버로 보내기 전에 적절한 로직을 작성해야 합니다.)

> **해설**
> Form Valid property has to be checked before adding the data to the database.
> `Built-In Validation` 속성이 `True`로 설정된 경우, OutSystems는 자동으로 폼의 유효성을 검사하여
> 잘못된 데이터가 서버로 전송되지 않도록 합니다.

---

## 문제 64

Which of the following is true with respect to the below screen setting? (아래 화면 설정과 관련하여 다음 중 옳은 것은 무엇입니까?)

- [ ] A. None Of Above (해당 사항 없음)
- [x] **B. No authentication is required. (인증이 필요하지 않습니다.)**
- [ ] C. Only users with valid credentials can access this screen. (유효한 자격 증명이 있는 사용자만 이 화면에 액세스할 수 있습니다.)
- [ ] D. Only users registered with the application can access this screen. (애플리케이션에 등록된 사용자만 이 화면에 액세스할 수 있습니다.)

> **해설**
> No authentication is required.
> As the Anonymous role is checked then there is no authentication required to access this screen,
> anyone on the web can access this screen.
> 화면의 역할에 `Anonymous`가 포함되어 있으므로, 인증 없이 누구나 웹에서 해당 화면에 접근할
> 수 있습니다.

---

## 문제 65

What would be the execution order of data action and screen aggregates while loading any screen? (화면을 로드할 때 데이터 액션과 화면 애그리게이트의 실행 순서는 어떻게 됩니까?)

- [ ] A. Aggregate is first and then Data action (Aggregate가 먼저이고 그 다음이 데이터 액션입니다.)
- [ ] B. Data action will be executed on start and aggregate will be on demand. (데이터 액션은 시작 시 실행되고 Aggregate는 필요할 때 실행됩니다.)
- [ ] C. Data Action is first and then Aggregate. (데이터 액션이 먼저이고 그 다음이 Aggregate입니다.)
- [x] **D. Both will be executed asynchronously. (둘 다 비동기적으로 실행됩니다.)**

> **해설**
> Both will be executed asynchronously.
> Data action and Screen aggregates are async operations.
> OutSystems에서 데이터 액션과 화면 애그리게이트는 비동기적으로 실행됩니다. 따라서 실행 순서
> 가 고정되어 있지 않으며, 둘 다 비동기 작업으로 처리됩니다. 정답은 **"Both will be executed
> asynchronously."**입니다.

---

## 문제 66

If there are 2 entities, User and Group. If one User belongs to only one Group, how can we create the one-to-many mapping between them? (User와 Group 두 엔티티가 있습니다. 한 명의 User가 하나의 Group에만 속하는 경우, 이들 간의 일대다 매핑을 어떻게 생성할 수 있습니까?)

- [ ] A. Create a new entity User_Group and put the identifier of both user and group in the newly created entity. (새 엔티티 User_Group을 생성하고 새로 생성된 엔티티에 사용자 및 그룹 식별자를 모두 넣습니다.)
- [ ] B. Create an attribute in Group with datatype as the User identifier. (데이터 유형이 User 식별자인 속성을 Group에 생성합니다.)
- [ ] C. Create only with join in between them. (둘 사이에 조인만 생성합니다.)
- [x] **D. Create an attribute in User with datatype as Group identifier. (데이터 유형이 Group 식별자인 속성을 User에 생성합니다.)**

> **해설**
> Create an attribute in User with datatype as Group identifier.
> 일대다 매핑을 만들기 위해, `User` 엔터티에 `Group` 식별자를 데이터 유형으로 하는 속성을 추가
> 해야 합니다. 이렇게 하면 한 `Group`에 여러 `User`가 속할 수 있습니다.

---

## 문제 67

Which of the following mappings between Outsystems and the database NOT is correct? (OutSystems와 데이터베이스 간의 매핑 중 옳지 않은 것은 무엇입니까?)

- [ ] A. Entities = Tables (엔티티 = 테이블)
- [ ] B. Attributes = Columns (속성 = 컬럼)
- [x] **C. Referential attribute = Primary Key (참조 속성 = 기본 키(Primary Key))**
- [ ] D. Index = Index (인덱스 = 인덱스)

> **해설**
> Referential attribute = Primary Key
> OutSystems에서 `Entities`는 데이터베이스 테이블, `Attributes`는 컬럼, `Index`는 인덱스와 매핑됩니
> 다. 하지만 `Referential attribute`(참조 속성)는 외래 키(Foreign Key)에 해당하며, 기본 키(Primary
> Key)와는 다릅니다. 따라서 잘못된 매핑은 **"Referential attribute = Primary Key"**입니다.

---

## 문제 68

Which of the below options can not be used inside an expression? (다음 옵션 중 Expression 내부에서 사용할 수 없는 것은 무엇입니까?)

- [x] **A. The output of server action. (서버 액션의 출력.)**
- [ ] B. Both output of server action and output of data action on the screen. (서버 액션의 출력과 화면의 데이터 액션 출력 모두.)
- [ ] C. The output of data action on the screen. (화면의 데이터 액션 출력.)
- [ ] D. addition formula of two local integer variables present on the screen. (화면에 있는 두 로컬 정수 변수의 덧셈 공식.)

> **해설**
> The output of server action
> We can not use the output of server action directly inside an expression.
> OutSystems에서 표현식(Expression) 내에서는 서버 액션의 출력을 직접 사용할 수 없습니다. 반면,
> 데이터 액션의 출력이나 화면의 로컬 정수 변수의 연산(예: 덧셈)은 표현식에서 사용할 수 있습니
> 다.

---

## 문제 69

Which is wrong in respect of buttons? (버튼과 관련하여 틀린 설명은 무엇입니까?)

- [ ] A. We can redirect to the outside of the OutSystems application on the OnClick of button (버튼의 OnClick 시 OutSystems 애플리케이션 외부로 리디렉션할 수 있습니다.)
- [ ] B. We can refresh the current screen on the Button's onClick event (버튼의 onClick 이벤트에서 현재 화면을 새로 고칠 수 있습니다.)
- [ ] C. We can navigate to another screen on the button's onClick event. (버튼의 onClick 이벤트에서 다른 화면으로 이동할 수 있습니다.)
- [x] **D. We can call a server action on the button's OnClick event (버튼의 OnClick 이벤트에서 서버 액션을 호출할 수 있습니다.)**

> **해설**
> We can call a server action on the button's OnClick event
> Server actions can not be called on buttons on click event.
> 버튼의 `OnClick` 이벤트는 외부 URL로 리디렉션, 현재 화면 새로고침, 다른 화면으로 이동 등을
> 수행할 수 있습니다. 하지만 서버 액션을 직접 호출할 수는 없습니다(클라이언트 액션을 통해 간
> 접 호출 가능).

---

## 문제 70

What will happen when we set the function property of public server action as "Yes"? (공용 서버 액션의 function 속성을 "Yes"로 설정하면 어떻게 됩니까?)

- [ ] A. It would only be defined with only one input parameter. (하나의 입력 매개변수만 정의될 수 있습니다.)
- [x] **B. It would only be defined with only one output parameter. (하나의 출력 매개변수만 정의될 수 있습니다.)**
- [ ] C. We would not be able to use this server action from another module. (다른 모듈에서 이 서버 액션을 사용할 수 없습니다.)
- [ ] D. It would only be used inside expressions. (Expression 내부에서만 사용됩니다.)

> **해설**
> It would only be defined with only one output parameter.
> 공용 서버 액션의 `Function` 속성을 `Yes`로 설정하면, 해당 액션은 표현식 편집기에서 함수처럼
> 사용할 수 있습니다. 이는 입력 및 출력 매개변수 제한을 강제하지 않으며, 다른 모듈에서도 여전
> 히 사용 가능합니다.

---

## 문제 71

What is true in respect of the web blocks? (웹 블록(Web blocks)과 관련하여 옳은 것은 무엇입니까?)

- [ ] A. An event is required to notify all the other instances about the changes made in the block. (블록의 변경 사항을 다른 모든 인스턴스에 알리려면 이벤트가 필요합니다.)
- [ ] B. It requires an event to fire every time when there is any change in the web block to reflect it on its instance. (인스턴스에 반영하기 위해 web block에 변경 사항이 있을 때마다 이벤트가 발생해야 합니다.)
- [x] **C. Changes made in the web block will automatically reflect in all its instances. (web block의 변경 사항은 자동으로 모든 인스턴스에 반영됩니다.)**
- [ ] D. The change has to be done manually on each instance of the block (변경 사항은 블록의 각 인스턴스에서 수동으로 수행되어야 합니다.)

> **해설**
> Changes made in the web block will automatically reflect in all its instances.
> 웹 블록은 재사용 가능한 구성 요소로, 블록 자체에 변경이 가해지면 모든 인스턴스에 자동으로
> 반영됩니다. 별도의 이벤트나 수동 작업이 필요 없습니다.

---

## 문제 72

Regarding Blocks in OutSystems reactive apps, which of the following options is correct? (OutSystems 반응형 앱의 블록에 대해 다음 중 옳은 옵션은 무엇입니까?)

- [x] **A. Blocks can be instantiated on Screens and other Blocks (블록은 화면 및 다른 블록에서 인스턴스화될 수 있습니다.)**
- [ ] B. Blocks can only be instantiated on Screens (블록은 화면에서만 인스턴스화될 수 있습니다.)
- [ ] C. Blocks can be instantiated on Screens and external HTML pages, using a special HTML tag. (특수 HTML 태그를 사용하여 화면 및 외부 HTML 페이지에서 블록을 인스턴스화할 수 있습니다.)
- [ ] D. Blocks can be instantiated on Client Actions on the Screen. (화면의 클라이언트 액션에서 블록을 인스턴스화할 수 있습니다.)

> **해설**
> Blocks can be instantiated on Screens and other Blocks
> OutSystems 반응형 앱에서 블록은 화면(Screens) 및 다른 블록 내에서 인스턴스화할 수 있습니다.
> 외부 HTML 페이지나 클라이언트 액션에서는 블록을 인스턴스화할 수 없습니다.

---

## 문제 73

Which of the below option is true regarding CreateOrUpdate entity action? (CreateOrUpdate 엔티티 액션에 대해 다음 중 옳은 것은 무엇입니까?)

- [ ] A. It returns the Id only when a new record is created. (새 레코드가 생성될 때만 Id를 반환합니다.)
- [ ] B. It only returns Id only when NullIdentifier() in Id is passed while calling the action. (액션을 호출할 때 Id에 NullIdentifier()가 전달된 경우에만 Id를 반환합니다.)
- [ ] C. It returns Id as well as a record that is updated or created. (업데이트되거나 생성된 레코드와 Id를 함께 반환합니다.)
- [x] **D. It returns only the ID of the created or updated record. (생성되거나 업데이트된 레코드의 ID만 반환합니다.)**

> **해설**
> It returns only the ID of the created or updated record.
> `CreateOrUpdate` 엔터티 액션은 레코드가 생성되거나 업데이트될 때, 해당 레코드의 ID를 반환합
> 니다.

---

## 문제 74

Which of the following is true? (다음 중 옳은 것은 무엇입니까?)

- [ ] A. Aggregates and DataActions execute in the same order as they are defined on the screen. (애그리게이트와 DataAction은 화면에 정의된 순서와 동일하게 실행됩니다.)
- [ ] B. We need to call aggregates and DataAction explicitly (애그리게이트와 DataAction을 명시적으로 호출해야 합니다.)
- [ ] C. DataAction executes before the aggregates. (DataAction은 애그리게이트보다 먼저 실행됩니다.)
- [x] **D. There is no order of aggregates and DataAction execution (애그리게이트와 DataAction의 실행 순서가 없습니다.)**

> **해설**
> There is no order of aggregates and DataAction execution
> 애그리게이트와 데이터 액션은 비동기적으로 실행되므로, 정의된 순서나 고정된 실행 순서가 없
> 습니다.

---

## 문제 75

What is correct in respect of screen actions? (화면 액션(Screen actions)과 관련하여 옳은 것은 무엇입니까?)

- [x] **A. All of above (위의 모든 사항)**
- [ ] B. Screen actions can not have output. (화면 액션(Screen actions)은 출력을 가질 수 없습니다.)
- [ ] C. Screen actions can not be called from outside of the screen (화면 액션은 화면 외부에서 호출할 수 없습니다.)
- [ ] D. Screen actions can not be called from client actions. (화면 액션은 클라이언트 액션에서 호출할 수 없습니다.)

> **해설**
> All of above
> 화면 액션(Screen Actions)은 해당 화면 내부에서만 호출 가능하며, 외부 모듈이나 다른 화면에서
> 호출할 수 없습니다. 또한, 화면 액션(Screen Actions)은 출력 변수를 가질 수 없고, 클라이언트 액
> 션은 호출할 수 있습니다.

---
